<!-- Generated by SpecStory -->

# Survey Schema Alignment Discussion (2025-04-27 12:44:43)

_**User**_

ok, after execution I get this 
schema 

"""Represents a block or section within a survey."""
type Block {
  id: ID
  name: String
  orderIndex: Int
  questions: [Question!]
  settings: [BlockSetting!]
  skipLogic: String
  survey: Survey
  surveyId: Int
  translations: [BlockTranslation!]
}

"""Settings specific to a block, represented as key-value pairs."""
type BlockSetting {
  block: Block
  blockId: Int
  settingKey: String
  settingValue: String
}

"""Translations for a Block's fields."""
type BlockTranslation {
  block: Block
  blockId: Int
  languageCode: String
  name: String
}

"""
Represents a single choice item for a question (e.g., an option in a radio button list).
"""
type ChoiceListItem {
  id: ID
  position: Int
  question: Question
  questionId: Int
  settingExclusive: Boolean
  settingVisible: Boolean
  translations: [ChoiceListItemTranslation!]
  value: String
}

"""Translations for a ChoiceListItem's fields."""
type ChoiceListItemTranslation {
  choiceListItem: ChoiceListItem
  choiceListItemId: Int
  label: String
  languageCode: String
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""The root query type"""
type Query {
  surveys: [Survey!]
}

"""Represents a question within a survey block."""
type Question {
  block: Block
  blockId: Int
  choiceItems: [ChoiceListItem!]
  id: ID
  isPageBreak: Boolean
  name: String
  orderIndex: Int
  settings: [QuestionSetting!]
  translations: [QuestionTranslation!]
  type: String
}

"""Settings specific to a question, represented as key-value pairs."""
type QuestionSetting {
  question: Question
  questionId: Int
  settingKey: String
  settingValue: String
}

"""Translations for a Question's fields."""
type QuestionTranslation {
  languageCode: String
  question: Question
  questionId: Int
  text: String
}

type Survey {
  blocks: [Block!]
  configVersion: Int
  createdAt: DateTime
  defaultLanguage: String
  id: ID
  languages: [SurveyLanguage!]
  name: String
  settings: [SurveySetting!]
  translations: [SurveyTranslation!]
}

"""Languages available for a specific survey."""
type SurveyLanguage {
  languageCode: String
  survey: Survey
  surveyId: Int
}

"""Settings specific to a survey, represented as key-value pairs."""
type SurveySetting {
  settingKey: String
  settingValue: String
  survey: Survey
  surveyId: Int
}

"""Translations for a Survey's fields."""
type SurveyTranslation {
  languageCode: String
  name: String
  survey: Survey
  surveyId: Int
}

is it alliend with @schema.prisma 

---

_**Assistant**_



---

Okay, I will ensure I only propose one change at a time.

Based on my comparison between the GraphQL schema you provided and the `server/prisma/schema.prisma` file, they are mostly aligned. Pothos handles the mapping from `snake_case` in Prisma to `camelCase` in GraphQL, and the types and relations generally match up.

However, there are two discrepancies:

1.  **Missing `schema_version` field**: The `Survey` model in `schema.prisma` has a `schema_version` field ( `schema_version String?`), but this field is not exposed in the `Survey` type definition within `server/src/builder.ts` and is therefore missing from your GraphQL schema.
2.  **Missing `use_s2` field**: The `Survey` model in `schema.prisma` has a `use_s2` field (`use_s2 Boolean`). This field *is* present in `server/src/builder.ts` but is currently commented out (`// useS2: t.exposeBoolean('use_s2'),`). This is why it's missing from your GraphQL schema.

Other than these two fields in the `Survey` type, the rest of the GraphQL schema appears consistent with the Prisma schema definitions and the way they are exposed in `server/src/builder.ts`. Nullable fields in Prisma are correctly represented as nullable in the GraphQL schema (e.g., `settingValue: String` is nullable, whereas `settingValue: String!` would be non-nullable).

---

_**User**_

ok, this is awsome, now In /api/chat @index.ts , I would like to include the schema generated as a part of system prompt, can you create a method which will pull the graphql schema , and print duration for this execution, and than inlcude this in my system prompt 

---

_**Assistant**_



---

Okay, I understand you want to fetch the GraphQL schema as a string, measure how long that takes, and include it in the system prompt for your `/api/chat` endpoint.

I will first add a helper function to get the schema string and measure the time, then integrate this into the `main` function to create the system prompt. This involves modifying `server/src/index.ts`.

Here is the proposed change:

```typescript
// server/src/index.ts
import "reflect-metadata";
import express from "express";
import type { Request, Response } from "express";
import cors from "cors";
import { streamText } from "ai";
import { openai } from "@ai-sdk/openai";
import { google } from '@ai-sdk/google';
import { anthropic } from '@ai-sdk/anthropic';
import { PrismaClient } from "@prisma/client";
import { createServer as createHttpServer } from "node:http";
import fetch from "node-fetch";
import getPort from "get-port";
// ++ Import printSchema from graphql ++
import { printSchema, type GraphQLSchema } from "graphql";

// Import utility function
import { getTimestamp } from "./utils/timestamp.js";

// Import MCP related functions
import { createMcpServer, setupMcpEndpoints, createMCPTools } from "./mcpServer.js";
// Import the new GraphQL setup function
import { setupGraphQLServer } from "./graphqlServer.js";
// ++ Import the Pothos schema from builder.ts again ++
import { schema } from "./builder.js";

// Base system prompt for the AI chat
const BASE_CHAT_SYSTEM_PROMPT =
  "You are a survey designer application. Be as supportive as possible. " +
  "If you need to use the GraphQL tool, always introspect the schema to find " +
  "the exact query or mutation you need to run. Only then should you execute the " +
  "operation. Do not guess or assume the schema; always verify first. " +
  "Keep the query for introspection short and concise. Prefer Human readable responses." +
  "\n\nThe available GraphQL schema is:\n```graphql\n{graphqlSchema}\n```";


// ++ Helper function to get schema string and measure duration ++
async function getGraphQLSchemaString(schemaObj: GraphQLSchema): Promise<string> {
  console.log(`${getTimestamp()} [Schema] Generating GraphQL schema string...`);
  const startTime = performance.now();
  const schemaString = printSchema(schemaObj);
  const endTime = performance.now();
  const duration = (endTime - startTime).toFixed(2);
  console.log(`${getTimestamp()} [Schema] Schema string generated in ${duration} ms.`);
  return schemaString;
}


// Helper function to get the AI model instance
type SupportedModel = "openai" | "claude" | "google";

function getAIModel(modelName: SupportedModel) {
  const modelMap = {
    openai: openai("gpt-4.1"),
    claude: anthropic("claude-3-7-sonnet-20250219"),
    google: google("gemini-2.5-pro-preview-03-25"),
  };

  if (!modelMap[modelName]) {
    console.warn(`${getTimestamp()} Unsupported model requested: ${modelName}. Defaulting to OpenAI.`);
    return modelMap.openai; // Or throw an error, depending on desired behavior
  }
  return modelMap[modelName];
}

async function main() {
  console.log(`${getTimestamp()} Starting server...`);

  const port = process.env.PORT
    ? Number.parseInt(process.env.PORT, 10)
    : await getPort({ port: 4000 });

  const graphqlPort = port; // Use the same port for GraphQL

  const app = express();
  app.use(cors());
  app.use(express.json({ limit: "50mb" }));

  // ++ Setup Prisma Client first ++
  const prisma = new PrismaClient();

  // ++ Setup GraphQL Server FIRST to get the finalized schema ++
  // Yoga server setup implicitly uses the imported 'schema'
  const yogaServer = await setupGraphQLServer(app, prisma);

  // ++ Get GraphQL schema string AFTER it's finalized/imported ++
  const schemaString = await getGraphQLSchemaString(schema);
  // ++ Construct the final system prompt ++
  const finalChatSystemPrompt = BASE_CHAT_SYSTEM_PROMPT.replace('{graphqlSchema}', schemaString);


  // ++ Setup MCP Server and Endpoints, passing the schema from the Yoga server ++
  // ++ Pass the imported schema directly, ensuring setupGraphQLServer runs first ++
  const mcpServer = createMcpServer();
  setupMcpEndpoints(app, mcpServer, () => graphqlPort, schema);

  // AI Chat endpoint
  app.post("/api/chat", async (req: Request, res: Response) => {
    console.log(`${getTimestamp()} --- /api/chat endpoint hit ---`);
    try {
      let { messages, model } = req.body as {
        messages: { role: "user" | "assistant" | "system"; content: string }[];
        model: "openai" | "claude" | "google";
      };

      const selectedModel = getAIModel(model);

      const tools = await createMCPTools(port);

      const result = streamText({
        model: selectedModel,
        messages,
        // ++ Use the dynamically generated system prompt ++
        system: finalChatSystemPrompt,
        tools: tools,
        maxSteps: 15,
      });

      result.pipeDataStreamToResponse(res);
    } catch (error) {
      console.error(`${getTimestamp()} Error in chat API:`, error);
      res.status(500).json({ error: "Internal Server Error" });
    }
  });

  // Start HTTP server
  const httpServer = createHttpServer(app);
  httpServer.listen(port, () => {
    console.log(`${getTimestamp()} [Server] Ready on http://localhost:${port}`);
    console.log(
      `${getTimestamp()} [Server] MCP SSE endpoints: GET http://localhost:${port}/sse, POST http://localhost:${port}/messages`
    );
    console.log(
      `${getTimestamp()} [Server] AI Chat endpoint at http://localhost:${port}/api/chat`
    );
  });

  // Graceful shutdown to close the Prisma client
  process.on("SIGINT", async () => {
    await prisma.$disconnect();
    process.exit(0);
  });

  process.on("SIGTERM", async () => {
    await prisma.$disconnect();
    process.exit(0);
  });
}

main().catch((err) => {
  console.error(`${getTimestamp()} [Server] Error starting server:`, err);
  process.exit(1);
});
```

**Explanation:**

1.  Imported `printSchema` and `GraphQLSchema` from the `graphql` package.
2.  Created the `getGraphQLSchemaString` async function which takes the Pothos `schema` object, uses `printSchema` to convert it to a string, measures the duration using `performance.now()`, logs the duration, and returns the string.
3.  Moved the base system prompt text into a constant `BASE_CHAT_SYSTEM_PROMPT` with a placeholder `{graphqlSchema}`.
4.  In `main`, after the schema is available (imported from `builder.ts`), called `getGraphQLSchemaString` to get the schema text.
5.  Constructed `finalChatSystemPrompt` by replacing the placeholder in the base prompt with the actual schema string.
6.  Updated the `/api/chat` endpoint to use `finalChatSystemPrompt` when calling `streamText`.

This change affects only `server/src/index.ts`. Let me know if you approve this change.

---

